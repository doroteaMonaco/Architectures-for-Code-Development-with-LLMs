[
    {
        "id": "valid_parentheses",
        "signature": "def is_valid(s: str) -> bool:",
        "docstring": "Check if the input string of parentheses is valid.",
        "examples": [
            {
                "input": "'()[]{}'",
                "output": "True"
            },
            {
                "input": "'(]'",
                "output": "False"
            }
        ],
        "difficulty": "Easy"
    },
    {
        "id": "Unique Binary Search Trees",
        "signature": "def num_trees(n: int) -> int:",
        "docstring": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.",
        "examples": [
            {
                "input": "3",
                "output": "5"
            },
            {
                "input": "1",
                "output": "1"
            }
        ],
        "difficulty": "Medium"
    },
    {
        "id": "Longest Increasing Subsequence",
        "signature": "def length_of_lis(nums: List[int], numsize: int) -> int:",
        "docstring": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
        "examples": [
            {
                "input": "[10,9,2,5,3,7,101,18], 8",
                "output": "4"
            },
            {
                "input": "[0,1,0,3,2,3], 6",
                "output": "4"
            }
        ],
        "difficulty": "Medium"
    },
    {
        "id": "Median of Two Sorted Arrays",
        "signature": "def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float:",
        "docstring": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
        "examples": [
            {
                "input": "[1,3], [2]",
                "output": "2.0"
            },
            {
                "input": "[1,2], [3,4]",
                "output": "2.5"
            }
        ],
        "difficulty": "Hard"
    },
    {
        "id": "Binary Tree Maximum Path Sum",
        "signature": "def max_path_sum(root: Optional[TreeNode]) -> int:",
        "docstring": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.",
        "examples": [
            {
                "input": "[1,2,3]",
                "output": "6"
            },
            {
                "input": "[-10,9,20,null,null,15,7]",
                "output": "42"
            }
        ],
        "difficulty": "Hard"
    }
]


